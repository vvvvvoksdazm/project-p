# -*- coding: utf-8 -*-
"""Копия блокнота "Untitled0.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zvi3xLCQQKg_BlSCTiKI8sgowQrD14eH
"""

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('Книга1.csv', delimiter=';', nrows=1716)
df

"""# Интерпретируем данные

Посмотрим, какие и сколько стран мы исследуем
"""

group_1 = df.groupby('Country')
unique_values = df['Country'].unique()
unique_values

len(unique_values)

"""Далее мы видим данные по ISO коду.

["Применение кодов позволяет сохранять время и избегать ошибок. Вместо названия страны (которое будет изменяться в зависимости от используемого языка) мы можем использовать комбинацию букв и/или цифр, которые будут понятны во всем мире".](https://www.iso.org/ru/iso-3166-country-codes.html)

Тогда количество ISO кодов должно совпадать с количеством стран. Проверим это.
"""

group_2 = df.groupby('ISO code')
unique_values_2 = df['ISO code'].unique()
unique_values_2

len(unique_values_2)

"""Количества стран и кодов совпали.

Из официальной документации период интерпретируется следующим образом (перевод):

[Данные "Около 1970" относятся к периоду с 1966 по 1975 год, данные "Около 1985" относятся к периоду с 1980 по 1989 год, данные "Около 1995" относятся к периоду с 1990 по 1999 год, данные "Около 2005" относятся к периоду с 2000 по 2008 год, а данные "Последние" относятся к последней точке данных, доступной после 2000 года. Каждому периоду соответствует только одна точка данных по стране. Периоды, отмеченные как "...", относятся к дополнительной точке данных в серии из пяти опорных дат. ](http://data.un.org/DocumentData.aspx?id=321)
"""

group_3 = df.groupby('Period')
unique_values_3 = df['Period'].unique()
unique_values_3

len(unique_values_3)

"""Существует неописанный в документации тип периода (nan)"""

group_4 = df.groupby('Year')
unique_values_4 = df['Year'].unique()
unique_values_4

len(unique_values_4)

"""Рассмотрим как исследуют по половому призннаку  """

group_5 = df.groupby('Sex')
unique_values_5 = df['Sex'].unique()
unique_values_5

len(unique_values_5)

"""Including consensual unions будем рассматривать как гражданские браки"""

group_6 = df.groupby('Including consensual unions')
unique_values_6 = df['Including consensual unions'].unique()
unique_values_6

"""В дальнейшем не используем этот показатель, так как не понятно, как интерпретировать его результаты

Рассмотрим типы источников информации
"""

group_7 = df.groupby('Source type')
unique_values_7 = df['Source type'].unique()
unique_values_7

len(unique_values_7)

"""Рассмотрим организации, которые предоставляли данную информацию"""

group_8 = df.groupby('Source')
unique_values_8 = df['Source'].unique()
unique_values_8

len(unique_values_8)

"""Всего 3 источника информации - опросы, перепись, подсчёты(?)

# Исследуем отсутствие данных, редактируем их для дальнейшей работы
"""

df.isna().any()

df.info()

"""#Визуализируем данные

Перед тем как пострить гистограммы по имеющимся числовым данным отметим, что SMAM (Singulate Mean Age at Marriage) - средний возраст вступления в брак
"""

import matplotlib.pyplot as plt

men = df[df['Sex']=='Men']
women = df[df['Sex']=='Women']

for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+', 'SMAM']:
  men_values = men[column].values
  women_values = women[column].values

  plt.hist(men_values, color='black', alpha=0.5, bins=50, label='Мужчины')
  plt.hist(women_values, color='red', alpha=0.5, bins=50, label='Женщины')
  plt.legend(loc='upper right')
  plt.xlabel('Значения')
  plt.ylabel('Количество')
  plt.title(f'Распределение показателя {column} среди мужчин и женщин')
  plt.show()

"""Заметим, что на всех графиках видно, что доля женщин в браке(значение) намного больше, чем мужчин """

import numpy as np

results_1 = dict()
for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:
  array = np.array(women[column])
  w_mean = women[column].mean(skipna=True)
  w_std = women[column].std(skipna=True)
  w_max = women[column].max(skipna=True)
  country_w_max = women.loc[women[column]==w_max]['Country']

  array = np.array(men[column])
  m_mean = men[column].mean(skipna=True)
  m_std = men[column].std(skipna=True)
  m_max = men[column].max(skipna=True)
  country_m_max = men.loc[men[column]==m_max]['Country']

  res = dict()
  
  res['Средняя доля мужчин'] = m_mean
  res['Средняя доля женщин'] = w_mean
  res['Стандартное отклонение для мужчин'] = m_std
  res['Стандартное отклонение для женщин'] = w_std
  res['Максимальная доля у мужчин'] = m_max
  res['Максимальная доля у женщин'] = w_max

  results_1[column] = res
  

import json
with open('results_1.json', 'w') as f:
    json.dump(results_1, f)

with open('results_1.json', 'r') as file:
    data = file.read()
    n_d = json.loads(data)

df_1 = pd.DataFrame(n_d)

df_1

"""Заметим, что до 50-54 лет доля женщин в браке превышает долю мужчин в браке, после данного возраста доли становятся примерно одинаковыми"""

array = np.array(women['SMAM'])
w = women['SMAM'].mean(skipna=True)

array = np.array(men['SMAM'])
m = men['SMAM'].mean(skipna=True)

print(f'Средний возраст у мужчин - {m}, женщин - {w} для показателя SMAM')

"""Как мы и предполагали: средний возраст вступления в брак у мужчин выше, чем у женщин

Теперь посмотрим на наше результаты с более формальной точки зрения. Протестируем гипотезу о равенстве среднего.

Создадим две выборки для каждого показателя

Результаты тестирования запишем в файл json.
Далее мы создадим датафрейм с результатами для наглядности
"""

from scipy.stats import ttest_ind

results = dict()
for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:
  mean = df[column].mean()
  df[column] = df[column].fillna(mean)
  w_test = df[df['Sex']=='Women'][column]
  m_test = df[df['Sex']=='Men'][column]
  t_stat, p_value = ttest_ind(w_test, m_test)

  m_d = np.mean(w_test) - np.mean(m_test)
  s_d = np.sqrt(np.var(w_test)/len(w_test) + np.var(m_test)/len(m_test))
  l = m_d - 1.96*s_d
  u = m_d + 1.96*s_d
  res = dict()
  
  res['p-value'] = p_value
  res['Разность средних'] = m_d
  res['95%-ый Доверительный интервал для разности средних'] = (l, u)
  if m_d > l and m_d < u:
    res['Нулевая гипотеза'] = 'ПРИНИМАЕТСЯ'
  else:
    res['Нулевая гипотеза'] = 'ОТВЕРГАЕТСЯ'

  results[column] = res

import json
with open('results.json', 'w') as f:
    json.dump(results, f)

with open('results.json', 'r') as file:
    data = file.read()
    n_d = json.loads(data)

df_2 = pd.DataFrame(n_d)

df_2

df_2.loc['Нулевая гипотеза'].unique()

"""То есть в каждом случае принимается нулевая гипотеза на 95 процентном доверительном интервале

А сейчас посмотрим на то, как распределны на графике страны, которые для разных возрастных категорий дают максимальные значения
"""

for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:

  fig, ax = plt.subplots(figsize=(10, 10))
  ax.scatter(women['Country'], women[column], s=100)
  plt.xticks(rotation=90)
  plt.xlabel('Страны')
  plt.ylabel(f'{column}')
  plt.title(f'Доля браков для женщин в категории {column}')
  plt.show()

"""Если смотреть на все страны, то их очень много, посмотрим только на те, что давали 100 процентов замужества"""

set_1 = set()
l1 = []
for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:
  
  country_w_max = women.loc[women[column]==w_max]['Country']
  set_1 = set_1|set(country_w_max)

for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:
  

  new_w = women.loc[women['Country'].isin(list(set_1))]
  fig, ax = plt.subplots(figsize=(10, 10))
  ax.scatter(new_w['Country'], new_w[column], s=100)
  plt.xticks(rotation=90)
  plt.xlabel('Страны')
  plt.ylabel(f'{column}')
  plt.title(f'Доля браков для женщин в категории {column}')
  plt.show()

set_2 = set()
for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:
  
  country_m_max = set(men.loc[men[column]==m_max]['Country'])
  set_2 = set_2|country_m_max

for column in ['15-19', '20-24', '25-29', '30-34', '35-39','40-44', '45-49', '50-54', '55-59', '60-64','65+']:
  

  new_m = men.loc[men['Country'].isin(list(set_2))]
  fig, ax = plt.subplots(figsize=(10, 10))
  ax.scatter(x = new_m['Country'], y = new_m[column], s=100)
  plt.xticks(rotation=90)
  plt.xlabel('Страны')
  plt.ylabel(f'{column}')
  plt.title(f'Доля браков для мужчин в категории {column}')
  plt.show()

"""# Материал для дальнейшего исследования

Для дальнейших исследований может пригодиться не только анализ числовых данных, но и исследвание медиа-сферы. Поэтому мы посмотри, какие статьи есть на тему брака на сайте The New York Times
"""

import requests
from bs4 import BeautifulSoup

resp = requests.get('https://www.nytimes.com/search?dropmab=false&endDate=20211231&query=marriage&sort=best&startDate=20200101')
res = BeautifulSoup(resp.text, 'html.parser')

with open('links.txt', 'w') as file:
    for link in res.find_all('a'):
        file.write(link.get('href') + '\n')

"""# Карта

Рассмотрим, в каких странах совершались браки, статистику по которым мы рассматривали
"""

import folium

df_3 = pd.DataFrame(columns= ['County', 'Latitude', 'Longitude'])

"""Чтобы нанести страны на карту, необходимо знать протяженность и долготу"""

from geopy.geocoders import Nominatim
for i in unique_values:
  #следущую строку мне помогли написать
  geolocator = Nominatim(user_agent='my_app')
  try:
    location = geolocator.geocode(i)
    df_3.loc[i, 'Country'] = i
    df_3.loc[i, 'Latitude'] = location.latitude
    df_3.loc[i, 'Longitude'] = location.longitude

  except AttributeError:
      continue

df_3 = df_3.dropna()

m_m = folium.Map(location=[df_3['Latitude'].mean(), df_3['Longitude'].mean()], zoom_start=1)
for i, j in df_3.iterrows():
    folium.Marker(location=[j['Latitude'], j['Longitude']], popup=j['Country']).add_to(m_m)
m_m

"""Рассмотрим новый датасет о браках, зарегистрированных в Москве, чтобы найти связь между id и State Registration Of Marriage"""

df_4 = pd.read_json('data-7523-2020-05-08.json')
df_4

import networkx as nx

grap_h = nx.Graph()

stateof = df_4['StateRegistrationOfMarriage'].unique()
id = df_4['ID']

grap_h.add_nodes_from(stateof)
grap_h.add_nodes_from(id)

for i, j in df_4.iterrows():
    grap_h.add_edge(j['StateRegistrationOfMarriage'], j['ID'])

nx.draw(grap_h, with_labels=True)
plt.show()
print('Центральные вершины:', nx.degree_centrality(grap_h))